# -*- coding: utf-8 -*-
"""RC4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zIDEvWKvB3-FnfOdUAU_zME21l4WCF0U
"""

# key scheduling algorithm
def ksa(key):
    key_length = len(key)
    # state array
    S = list(range(256))
    # index for permutations
    j = 0

    # Convert key characters to ASCII values
    key = [ord(char) for char in key]

    # generating the final state array
    for i in range(256):
        # array permutation based on the key
        j = (j + S[i] + key[i % key_length]) % 256
        S[i], S[j] = S[j], S[i]

    return S

# pseudo-random generation algorithm
def prga(S, data):
    # pointers for updating and generating the key stream
    i = j = 0
    result = []

    # pseudo-random bytes generation
    for byte in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]

        # XORing each byte of the input data with the pseudo-random bytes generated
        t = (S[i] + S[j]) % 256
        result.append(byte ^ S[t])

    return bytes(result)

# produce the final pseudo-random stream
def rc4(key, data):
    S = ksa(key)
    return prga(S, data)

# encryption
def rc4_encrypt(key, plaintext):
    plaintext_bytes = [ord(char) for char in plaintext]
    ciphertext_bytes = rc4(key, plaintext_bytes)
    return bytes(ciphertext_bytes)

# decryption
def rc4_decrypt(key, ciphertext):
    ciphertext_bytes = eval(ciphertext.encode('utf-8'))
    ciphertext_bytes = [byte for byte in ciphertext_bytes]
    decrypted_bytes = rc4(key, ciphertext_bytes)
    decrypted_text = ''.join([chr(byte) for byte in decrypted_bytes])
    return decrypted_text



