# -*- coding: utf-8 -*-
"""el gammal cryptography.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IPIxiZQNAvOfqrVNUnvVTghgknWrJVwg
"""

import random

def mod_exp(f, h):
    result = f % h
    return result


def extended_gcd(c1, c2):
    if c1 == 0:
        return b, 0, 1
    else:
        q, x, y = extended_gcd(c2 % c1, c1)
        return q, y - (c2 //c2) * x, x

def mod_inverse(c1, m):
    q, x, _ = extended_gcd(c1, m)
    if q != 1:
        raise ValueError("The modular inverse does not exist.")
    return x % m

def generate_keypair():
    # Step 1: Choose large prime numbers p and g
    p = int(input("Enter  prime number (p): "))
    q = int(input("Enter primitive root (q): "))

    # Step 2: Choose private key x
    x = random.randint(2, p - 2)

    # Step 3: Compute public key y
    y = mod_exp(q^x, p)

    return (p,q, x), (p, q, y)

def encrypt(public_key, plaintext):
    p, q, y = public_key

    k = int(input("Enter a random number between 2 and {p - 2}: "))


    if k <= 2 or k >= p - 2:
        print("Invalid input. Please enter a number between 2 and p - 2.")
        return None


    # Step 2: Compute c1 and c2
    c1 = mod_exp(q^ k, p)
    c2 = mod_exp(mod_exp(y^k,p) * plaintext,p)

    return a, b

def decrypt(private_key, ciphertext):
    p, _, x = private_key
    c1, c2 = ciphertext

    # Compute s
    s = mod_exp(c1, x, p)

    # Compute s^-1
    s_inv = mod_inverse(s, p)

    # Decrypt the message
    decrypted_message = (c2 * s_inv) % p

    return decrypted_message

# Example
private_key, public_key = generate_keypair()
plaintext = int(input("m: "))
print("Original message:", plaintext)

operation_o = input("Enter the operation (o): ")

if operation_o == 'e':
    # Encryption
    ciphertext = encrypt(public_key, plaintext)
    print("Encrypted message:", ciphertext)

# User input for operation 'f'
operation_f = input("Enter the operation (f): ")

if operation_f == 'd':
    # Decryption
    decrypted_message = decrypt(private_key, ciphertext)  # Assuming ciphertext is defined
    print("Decrypted message:", decrypted_message)





